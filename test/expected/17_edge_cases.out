-- Test 17: Edge Cases
-- Tests various edge cases and boundary conditions
-- Suppress NOTICE messages for cleaner test output
SET client_min_messages = warning;
-- Clean up from previous runs
DROP TABLE IF EXISTS test_edge_empty;
DROP TABLE IF EXISTS test_edge_single;
DROP TABLE IF EXISTS test_edge_types;
DROP TABLE IF EXISTS test_edge_large;
DROP TABLE IF EXISTS test_edge_special;
-- ================================================================
-- Test 1: Empty table operations
-- ================================================================
CREATE TABLE test_edge_empty (id INT, ver INT, data TEXT NOT NULL) USING xpatch;
-- SELECT on empty table
SELECT 
    CASE WHEN COUNT(*) = 0 
         THEN 'PASS: Empty table COUNT' 
         ELSE 'FAIL: Empty table COUNT' 
    END as result
FROM test_edge_empty;
         result          
-------------------------
 PASS: Empty table COUNT
(1 row)

-- Aggregates on empty table
SELECT 
    CASE WHEN MAX(ver) IS NULL 
         THEN 'PASS: Empty table MAX' 
         ELSE 'FAIL: Empty table MAX' 
    END as result
FROM test_edge_empty;
        result         
-----------------------
 PASS: Empty table MAX
(1 row)

-- WHERE clause on empty table
SELECT 
    CASE WHEN COUNT(*) = 0 
         THEN 'PASS: Empty table WHERE' 
         ELSE 'FAIL: Empty table WHERE' 
    END as result
FROM test_edge_empty WHERE id = 1;
         result          
-------------------------
 PASS: Empty table WHERE
(1 row)

-- ================================================================
-- Test 2: Single row table
-- ================================================================
CREATE TABLE test_edge_single (id INT, ver INT, data TEXT NOT NULL) USING xpatch;
INSERT INTO test_edge_single VALUES (1, 1, 'Only row');
-- Single row is a keyframe (no delta)
SELECT 
    CASE WHEN keyframe_count = 1 AND delta_count = 0 
         THEN 'PASS: Single row is keyframe' 
         ELSE 'FAIL: Single row handling' 
    END as result
FROM xpatch_stats('test_edge_single');
            result            
------------------------------
 PASS: Single row is keyframe
(1 row)

-- Query the single row
SELECT id, ver, data FROM test_edge_single;
 id | ver |   data   
----+-----+----------
  1 |   1 | Only row
(1 row)

-- ================================================================
-- Test 3: Unusual data types
-- ================================================================
CREATE TABLE test_edge_types (
    uuid_id UUID,
    ver INT,
    json_data JSON,
    jsonb_data JSONB,
    bytea_data BYTEA NOT NULL,
    array_data INT[],
    numeric_data NUMERIC(20,5),
    ts_data TIMESTAMP,
    bool_data BOOLEAN
) USING xpatch;
SELECT xpatch.configure('test_edge_types', group_by => 'uuid_id');
 configure 
-----------
 
(1 row)

-- Insert with unusual types
INSERT INTO test_edge_types VALUES (
    'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
    1,
    '{"key": "value1"}',
    '{"num": 1}',
    '\x0102030405',
    ARRAY[1,2,3],
    12345.67890,
    '2024-01-01 12:00:00',
    true
);
INSERT INTO test_edge_types VALUES (
    'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11',
    2,
    '{"key": "value2"}',
    '{"num": 2}',
    '\x0102030406',
    ARRAY[1,2,4],
    12345.67891,
    '2024-01-02 12:00:00',
    false
);
-- Verify data round-trips correctly
SELECT 
    CASE WHEN json_data::text = '{"key": "value2"}' 
         THEN 'PASS: JSON round-trip' 
         ELSE 'FAIL: JSON round-trip' 
    END as result
FROM test_edge_types WHERE ver = 2;
        result         
-----------------------
 PASS: JSON round-trip
(1 row)

SELECT 
    CASE WHEN jsonb_data->>'num' = '2' 
         THEN 'PASS: JSONB round-trip' 
         ELSE 'FAIL: JSONB round-trip' 
    END as result
FROM test_edge_types WHERE ver = 2;
         result         
------------------------
 PASS: JSONB round-trip
(1 row)

SELECT 
    CASE WHEN array_data = ARRAY[1,2,4] 
         THEN 'PASS: Array round-trip' 
         ELSE 'FAIL: Array round-trip' 
    END as result
FROM test_edge_types WHERE ver = 2;
         result         
------------------------
 PASS: Array round-trip
(1 row)

-- ================================================================
-- Test 4: Large data values
-- ================================================================
CREATE TABLE test_edge_large (id INT, ver INT, data TEXT NOT NULL) USING xpatch;
SELECT xpatch.configure('test_edge_large', group_by => 'id');
 configure 
-----------
 
(1 row)

-- Insert large text (1MB)
INSERT INTO test_edge_large VALUES (1, 1, repeat('x', 1000000));
INSERT INTO test_edge_large VALUES (1, 2, repeat('x', 1000000) || 'changed');
-- Verify data integrity
SELECT 
    CASE WHEN length(data) = 1000007 
         THEN 'PASS: Large data handling' 
         ELSE 'FAIL: Large data handling' 
    END as result
FROM test_edge_large WHERE ver = 2;
          result           
---------------------------
 PASS: Large data handling
(1 row)

-- ================================================================
-- Test 5: Special characters in data
-- ================================================================
CREATE TABLE test_edge_special (id INT, ver INT, data TEXT NOT NULL) USING xpatch;
-- Insert with special characters
INSERT INTO test_edge_special VALUES (1, 1, E'Line1\nLine2\tTabbed');
INSERT INTO test_edge_special VALUES (1, 2, E'Line1\nLine2\tTabbed\r\nWindows');
INSERT INTO test_edge_special VALUES (1, 3, 'Unicode: ' || chr(233) || chr(8364) || chr(12354));
-- Verify special characters preserved
SELECT 
    CASE WHEN data LIKE E'%\n%' 
         THEN 'PASS: Newline preserved' 
         ELSE 'FAIL: Newline not preserved' 
    END as result
FROM test_edge_special WHERE ver = 1;
         result          
-------------------------
 PASS: Newline preserved
(1 row)

SELECT 
    CASE WHEN data LIKE E'%\t%' 
         THEN 'PASS: Tab preserved' 
         ELSE 'FAIL: Tab not preserved' 
    END as result
FROM test_edge_special WHERE ver = 1;
       result        
---------------------
 PASS: Tab preserved
(1 row)

-- ================================================================
-- Test 6: NULL values in columns
-- ================================================================
DROP TABLE IF EXISTS test_edge_nulls;
CREATE TABLE test_edge_nulls (id INT, ver INT, data TEXT NOT NULL, optional TEXT) USING xpatch;
SELECT xpatch.configure('test_edge_nulls', group_by => 'id');
 configure 
-----------
 
(1 row)

-- Insert with NULL values in non-delta column (optional)
-- Note: data is NOT NULL because it's a delta column
INSERT INTO test_edge_nulls VALUES (1, 1, 'Has data', NULL);
INSERT INTO test_edge_nulls VALUES (1, 2, 'Also has data', 'Has optional');
INSERT INTO test_edge_nulls VALUES (1, 3, 'Both', 'Both');
-- Verify NULL handling in non-delta column
SELECT 
    CASE WHEN optional IS NULL 
         THEN 'PASS: NULL preserved v1' 
         ELSE 'FAIL: NULL not preserved v1' 
    END as result
FROM test_edge_nulls WHERE ver = 1;
         result          
-------------------------
 PASS: NULL preserved v1
(1 row)

SELECT 
    CASE WHEN optional IS NOT NULL 
         THEN 'PASS: Value preserved v2' 
         ELSE 'FAIL: Value not preserved v2' 
    END as result
FROM test_edge_nulls WHERE ver = 2;
          result          
--------------------------
 PASS: Value preserved v2
(1 row)

-- ================================================================
-- Test 7: Many small groups
-- ================================================================
DROP TABLE IF EXISTS test_edge_many_groups;
CREATE TABLE test_edge_many_groups (id INT, ver INT, data TEXT NOT NULL) USING xpatch;
SELECT xpatch.configure('test_edge_many_groups', group_by => 'id');
 configure 
-----------
 
(1 row)

-- Create 1000 groups with 1 row each
INSERT INTO test_edge_many_groups 
SELECT g, 1, 'Data for group ' || g 
FROM generate_series(1, 1000) AS g;
-- Verify all groups are keyframes
SELECT 
    CASE WHEN keyframe_count = 1000 AND delta_count = 0 
         THEN 'PASS: Many groups all keyframes' 
         ELSE 'FAIL: Many groups handling' 
    END as result
FROM xpatch_stats('test_edge_many_groups');
             result              
---------------------------------
 PASS: Many groups all keyframes
(1 row)

-- ================================================================
-- Test 8: Deep version chain (many versions per group)
-- ================================================================
DROP TABLE IF EXISTS test_edge_deep;
CREATE TABLE test_edge_deep (id INT, ver INT, data TEXT NOT NULL) USING xpatch;
SELECT xpatch.configure('test_edge_deep', group_by => 'id', keyframe_every => 10);
 configure 
-----------
 
(1 row)

-- Create 100 versions for one group
INSERT INTO test_edge_deep 
SELECT 1, v, repeat('Version ' || v || ' data. ', 50)
FROM generate_series(1, 100) AS v;
-- Should have 10 keyframes (every 10 versions)
SELECT 
    CASE WHEN keyframe_count = 10 
         THEN 'PASS: Deep chain keyframes' 
         ELSE 'FAIL: Deep chain keyframes (expected 10, got ' || keyframe_count || ')' 
    END as result
FROM xpatch_stats('test_edge_deep');
           result           
----------------------------
 PASS: Deep chain keyframes
(1 row)

-- Verify all versions accessible
SELECT 
    CASE WHEN COUNT(*) = 100 
         THEN 'PASS: All deep versions accessible' 
         ELSE 'FAIL: Not all deep versions accessible' 
    END as result
FROM test_edge_deep;
               result               
------------------------------------
 PASS: All deep versions accessible
(1 row)

-- Clean up
DROP TABLE test_edge_empty;
DROP TABLE test_edge_single;
DROP TABLE test_edge_types;
DROP TABLE test_edge_large;
DROP TABLE test_edge_special;
DROP TABLE test_edge_nulls;
DROP TABLE test_edge_many_groups;
DROP TABLE test_edge_deep;
