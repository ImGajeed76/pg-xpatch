-- Test 16: Automatic Index Creation
-- Tests automatic index creation on table creation and configuration
-- Suppress NOTICE messages for cleaner test output
SET client_min_messages = warning;
-- Clean up from previous runs
DROP TABLE IF EXISTS test_idx_basic;
DROP TABLE IF EXISTS test_idx_configured;
DROP TABLE IF EXISTS test_idx_existing;
-- ================================================================
-- Test 1: Basic index created on table creation
-- ================================================================
CREATE TABLE test_idx_basic (
    id INT,
    version INT,
    data TEXT NOT NULL
) USING xpatch;
-- Check that _xp_seq index was created automatically
SELECT 
    CASE WHEN COUNT(*) = 1 
         THEN 'PASS: Basic index created' 
         ELSE 'FAIL: Basic index not created' 
    END as result
FROM pg_indexes 
WHERE tablename = 'test_idx_basic' AND indexname LIKE '%xp_seq%';
          result           
---------------------------
 PASS: Basic index created
(1 row)

-- Show the index name
SELECT indexname FROM pg_indexes WHERE tablename = 'test_idx_basic';
         indexname         
---------------------------
 test_idx_basic_xp_seq_idx
(1 row)

-- ================================================================
-- Test 2: Composite index created on configure with group_by
-- ================================================================
CREATE TABLE test_idx_configured (
    doc_id INT,
    version INT,
    content TEXT NOT NULL
) USING xpatch;
-- Before configure: should have basic _xp_seq index
SELECT indexname FROM pg_indexes WHERE tablename = 'test_idx_configured';
           indexname            
--------------------------------
 test_idx_configured_xp_seq_idx
(1 row)

-- Configure with group_by
SELECT xpatch.configure('test_idx_configured', group_by => 'doc_id');
 configure 
-----------
 
(1 row)

-- After configure: should have composite index, basic one dropped
SELECT 
    CASE WHEN indexname LIKE '%group_seq%' 
         THEN 'PASS: Composite index created' 
         ELSE 'FAIL: Composite index not created' 
    END as result
FROM pg_indexes 
WHERE tablename = 'test_idx_configured';
            result             
-------------------------------
 PASS: Composite index created
(1 row)

-- Verify basic index was dropped
SELECT 
    CASE WHEN COUNT(*) = 0 
         THEN 'PASS: Basic index dropped' 
         ELSE 'FAIL: Basic index not dropped' 
    END as result
FROM pg_indexes 
WHERE tablename = 'test_idx_configured' AND indexname LIKE '%xp_seq_idx';
          result           
---------------------------
 PASS: Basic index dropped
(1 row)

-- ================================================================
-- Test 3: Index on table with existing data
-- Note: We configure first, then insert, because without group_by
-- all rows would be in the same version chain (invalid)
-- ================================================================
CREATE TABLE test_idx_existing (
    id INT,
    ver INT,
    data TEXT NOT NULL
) USING xpatch;
-- Configure FIRST so we can have multiple groups
SELECT xpatch.configure('test_idx_existing', group_by => 'id');
 configure 
-----------
 
(1 row)

-- Drop the composite index so we can test re-creation
DROP INDEX test_idx_existing_xp_group_seq_idx;
-- Insert data (now properly grouped)
INSERT INTO test_idx_existing SELECT d, v, 'Data ' || d || '-' || v 
FROM generate_series(1, 10) AS d, generate_series(1, 5) AS v
ORDER BY d, v;
-- Re-run configure to create index on existing data
SELECT xpatch.configure('test_idx_existing', group_by => 'id');
 configure 
-----------
 
(1 row)

-- Verify composite index exists
SELECT 
    CASE WHEN COUNT(*) = 1 
         THEN 'PASS: Index created on existing data' 
         ELSE 'FAIL: Index not created on existing data' 
    END as result
FROM pg_indexes 
WHERE tablename = 'test_idx_existing' AND indexname LIKE '%group_seq%';
                result                
--------------------------------------
 PASS: Index created on existing data
(1 row)

-- Verify data is still accessible
SELECT 
    CASE WHEN COUNT(*) = 50 
         THEN 'PASS: Data accessible after index creation' 
         ELSE 'FAIL: Data not accessible' 
    END as result
FROM test_idx_existing;
                   result                   
--------------------------------------------
 PASS: Data accessible after index creation
(1 row)

-- ================================================================
-- Test 4: Index survives TRUNCATE
-- ================================================================
-- Check index before truncate
SELECT indexname FROM pg_indexes WHERE tablename = 'test_idx_existing';
             indexname              
------------------------------------
 test_idx_existing_xp_group_seq_idx
(1 row)

TRUNCATE test_idx_existing;
-- Check index after truncate
SELECT 
    CASE WHEN COUNT(*) = 1 
         THEN 'PASS: Index survives TRUNCATE' 
         ELSE 'FAIL: Index lost after TRUNCATE' 
    END as result
FROM pg_indexes 
WHERE tablename = 'test_idx_existing' AND indexname LIKE '%group_seq%';
            result             
-------------------------------
 PASS: Index survives TRUNCATE
(1 row)

-- ================================================================
-- Test 5: Index is used by query planner
-- ================================================================
-- Re-insert data
INSERT INTO test_idx_existing SELECT d, v, 'Data ' || d || '-' || v 
FROM generate_series(1, 100) AS d, generate_series(1, 10) AS v;
ANALYZE test_idx_existing;
-- Force index usage
SET enable_seqscan = off;
-- Check that index is used
EXPLAIN (COSTS OFF) SELECT * FROM test_idx_existing WHERE id = 50;
                          QUERY PLAN                           
---------------------------------------------------------------
 Bitmap Heap Scan on test_idx_existing
   Recheck Cond: (id = 50)
   ->  Bitmap Index Scan on test_idx_existing_xp_group_seq_idx
         Index Cond: (id = 50)
(4 rows)

SET enable_seqscan = on;
-- Clean up
DROP TABLE test_idx_basic;
DROP TABLE test_idx_configured;
DROP TABLE test_idx_existing;
